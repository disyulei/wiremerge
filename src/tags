!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ASSERT	RTree.h	14;"	d
AddBranch	RTree.h	/^bool RTREE_QUAL::AddBranch(Branch* a_branch, Node* a_node, Node** a_newNode)$/;"	f	class:RTREE_QUAL
AllocListNode	RTree.h	/^typename RTREE_QUAL::ListNode* RTREE_QUAL::AllocListNode()$/;"	f	class:RTREE_QUAL
AllocNode	RTree.h	/^typename RTREE_QUAL::Node* RTREE_QUAL::AllocNode()$/;"	f	class:RTREE_QUAL
Branch	RTree.h	/^  struct Branch$/;"	s	class:RTree
CalcRectVolume	RTree.h	/^ELEMTYPEREAL RTREE_QUAL::CalcRectVolume(Rect* a_rect)$/;"	f	class:RTREE_QUAL
ChoosePartition	RTree.h	/^void RTREE_QUAL::ChoosePartition(PartitionVars* a_parVars, int a_minFill)$/;"	f	class:RTREE_QUAL
Classify	RTree.h	/^void RTREE_QUAL::Classify(int a_index, int a_group, PartitionVars* a_parVars)$/;"	f	class:RTREE_QUAL
Close	RTree.h	/^  void Close()$/;"	f	class:RTFileStream
CombineRect	RTree.h	/^typename RTREE_QUAL::Rect RTREE_QUAL::CombineRect(Rect* a_rectA, Rect* a_rectB)$/;"	f	class:RTREE_QUAL
Count	RTree.h	/^int RTREE_QUAL::Count()$/;"	f	class:RTREE_QUAL
CountRec	RTree.h	/^void RTREE_QUAL::CountRec(Node* a_node, int& a_count)$/;"	f	class:RTREE_QUAL
Debug_Output	Design.cpp	/^Design::Debug_Output(string file)$/;"	f	class:Design
Debug_RealBoxes	Design.cpp	/^Design::Debug_RealBoxes(string file)$/;"	f	class:Design
Design	Design.cpp	/^Design::Design()$/;"	f	class:Design
Design	Design.h	/^class Design$/;"	c
DisconnectBranch	RTree.h	/^void RTREE_QUAL::DisconnectBranch(Node* a_node, int a_index)$/;"	f	class:RTREE_QUAL
F	PTR.cpp	/^PTR::F(oaPointArray & points, int X, int Y)$/;"	f	class:PTR
FP	myShape.h	/^  typedef int (myShape::*FP) ();$/;"	t	class:myShape
FindNextData	RTree.h	/^    bool FindNextData()$/;"	f	class:RTree::Iterator
FindPkPlPm	PTR.cpp	/^PTR::FindPkPlPm(const oaPointArray points, oaPoint& Pk, oaPoint& Pl, oaPoint & Pm)$/;"	f	class:PTR
FreeListNode	RTree.h	/^void RTREE_QUAL::FreeListNode(ListNode* a_listNode)$/;"	f	class:RTREE_QUAL
FreeNode	RTree.h	/^void RTREE_QUAL::FreeNode(Node* a_node)$/;"	f	class:RTREE_QUAL
GetAreas	myShape.cpp	/^myShape::GetAreas()$/;"	f	class:myShape
GetAt	RTree.h	/^  DATATYPE& GetAt(Iterator& a_it)                 { return *a_it; }$/;"	f	class:RTree
GetBounds	RTree.h	/^    void GetBounds(ELEMTYPE a_min[NUMDIMS], ELEMTYPE a_max[NUMDIMS])$/;"	f	class:RTree::Iterator
GetBranches	RTree.h	/^void RTREE_QUAL::GetBranches(Node* a_node, Branch* a_branch, PartitionVars* a_parVars)$/;"	f	class:RTREE_QUAL
GetFirst	RTree.h	/^  void GetFirst(Iterator& a_it)$/;"	f	class:RTree
GetID	myShape.h	/^  int     GetID()    { return m_id; }$/;"	f	class:myShape
GetNext	RTree.h	/^  void GetNext(Iterator& a_it)                    { ++a_it; }$/;"	f	class:RTree
GetoaBox	myShape.h	/^  oaBox*  GetoaBox() { return m_realBox; }$/;"	f	class:myShape
Graph	main.h	/^typedef boost::adjacency_list <boost::vecS, boost::vecS, boost::undirectedS> Graph;$/;"	t
Init	RTree.h	/^    void Init()                                   { m_tos = 0; }$/;"	f	class:RTree::Iterator
InitNode	RTree.h	/^void RTREE_QUAL::InitNode(Node* a_node)$/;"	f	class:RTREE_QUAL
InitParVars	RTree.h	/^void RTREE_QUAL::InitParVars(PartitionVars* a_parVars, int a_maxRects, int a_minFill)$/;"	f	class:RTREE_QUAL
InitRect	RTree.h	/^void RTREE_QUAL::InitRect(Rect* a_rect)$/;"	f	class:RTREE_QUAL
Insert	RTree.h	/^void RTREE_QUAL::Insert(const ELEMTYPE a_min[NUMDIMS], const ELEMTYPE a_max[NUMDIMS], const DATATYPE& a_dataId)$/;"	f	class:RTREE_QUAL
InsertRect	RTree.h	/^bool RTREE_QUAL::InsertRect(Rect* a_rect, const DATATYPE& a_id, Node** a_root, int a_level)$/;"	f	class:RTREE_QUAL
InsertRectRec	RTree.h	/^bool RTREE_QUAL::InsertRectRec(Rect* a_rect, const DATATYPE& a_id, Node* a_node, Node** a_newNode, int a_level)$/;"	f	class:RTREE_QUAL
IsInternalNode	RTree.h	/^    bool IsInternalNode()                         { return (m_level > 0); } \/\/ Not a leaf, but a internal node$/;"	f	struct:RTree::Node
IsLeaf	RTree.h	/^    bool IsLeaf()                                 { return (m_level == 0); } \/\/ A leaf, contains data$/;"	f	struct:RTree::Node
IsNotNull	RTree.h	/^    bool IsNotNull()                              { return (m_tos > 0); }$/;"	f	class:RTree::Iterator
IsNull	RTree.h	/^    bool IsNull()                                 { return (m_tos <= 0); }$/;"	f	class:RTree::Iterator
IsNull	RTree.h	/^  bool IsNull(Iterator& a_it)                     { return a_it.IsNull(); }$/;"	f	class:RTree
Iterator	RTree.h	/^    Iterator()                                    { Init(); }$/;"	f	class:RTree::Iterator
Iterator	RTree.h	/^  class Iterator$/;"	c	class:RTree
ListNode	RTree.h	/^  struct ListNode$/;"	s	class:RTree
Load	RTree.h	/^bool RTREE_QUAL::Load(RTFileStream& a_stream)$/;"	f	class:RTREE_QUAL
Load	RTree.h	/^bool RTREE_QUAL::Load(const char* a_fileName)$/;"	f	class:RTREE_QUAL
LoadNodes	RTree.h	/^void RTREE_QUAL::LoadNodes(Node* a_nodeA, Node* a_nodeB, PartitionVars* a_parVars)$/;"	f	class:RTREE_QUAL
LoadRec	RTree.h	/^bool RTREE_QUAL::LoadRec(Node* a_node, RTFileStream& a_stream)$/;"	f	class:RTREE_QUAL
MAXNODES	RTree.h	/^    MAXNODES = TMAXNODES,                         \/\/\/< Max elements in node$/;"	e	enum:RTree::__anon1
MAX_STACK	RTree.h	/^    enum { MAX_STACK = 32 }; \/\/  Max stack size. Allows almost n^32 where n is number of branches in node$/;"	e	enum:RTree::Iterator::__anon2
MINNODES	RTree.h	/^    MINNODES = TMINNODES,                         \/\/\/< Min elements in node$/;"	e	enum:RTree::__anon1
Max	RTree.h	19;"	d
MergeWires	Design.cpp	/^Design::MergeWires()$/;"	f	class:Design
Min	RTree.h	16;"	d
Node	RTree.h	/^  struct Node$/;"	s	class:RTree
NodeCover	RTree.h	/^typename RTREE_QUAL::Rect RTREE_QUAL::NodeCover(Node* a_node)$/;"	f	class:RTREE_QUAL
OpenRead	RTree.h	/^  bool OpenRead(const char* a_fileName)$/;"	f	class:RTFileStream
OpenWrite	RTree.h	/^  bool OpenWrite(const char* a_fileName)$/;"	f	class:RTFileStream
OutputASCII	Design.cpp	/^Design::OutputASCII()$/;"	f	class:Design
Overlap	RTree.h	/^bool RTREE_QUAL::Overlap(Rect* a_rectA, Rect* a_rectB)$/;"	f	class:RTREE_QUAL
PTR	PTR.h	/^class PTR$/;"	c
PartitionVars	RTree.h	/^  struct PartitionVars$/;"	s	class:RTree
PickBranch	RTree.h	/^int RTREE_QUAL::PickBranch(Rect* a_rect, Node* a_node)$/;"	f	class:RTREE_QUAL
PickSeeds	RTree.h	/^void RTREE_QUAL::PickSeeds(PartitionVars* a_parVars)$/;"	f	class:RTREE_QUAL
Point	main.h	/^typedef gtl::point_data<int> Point;$/;"	t
Polygon	main.h	/^typedef gtl::polygon_data<int> Polygon;$/;"	t
Polygon2Rectangle	PTR.cpp	/^PTR::Polygon2Rectangle(oaPointArray & points, vector<oaBox> & vBoxes)$/;"	f	class:PTR
Pop	RTree.h	/^    StackElement& Pop()$/;"	f	class:RTree::Iterator
Push	RTree.h	/^    void Push(Node* a_node, int a_branchIndex)$/;"	f	class:RTree::Iterator
RTFileStream	RTree.h	/^  RTFileStream()$/;"	f	class:RTFileStream
RTFileStream	RTree.h	/^class RTFileStream$/;"	c
RTREE_DONT_USE_MEMPOOLS	RTree.h	31;"	d
RTREE_H	RTree.h	2;"	d
RTREE_QUAL	RTree.h	1595;"	d
RTREE_QUAL	RTree.h	29;"	d
RTREE_TEMPLATE	RTree.h	1594;"	d
RTREE_TEMPLATE	RTree.h	28;"	d
RTREE_USE_SPHERICAL_VOLUME	RTree.h	32;"	d
RTree	RTree.h	/^RTREE_QUAL::RTree()$/;"	f	class:RTREE_QUAL
RTree	RTree.h	/^class RTree$/;"	c
ReInsert	RTree.h	/^void RTREE_QUAL::ReInsert(Node* a_node, ListNode** a_listNode)$/;"	f	class:RTREE_QUAL
Read	RTree.h	/^  size_t Read(TYPE& a_value)$/;"	f	class:RTFileStream
ReadASCII	Design.cpp	/^Design::ReadASCII()$/;"	f	class:Design
ReadAll	Design.cpp	/^Design::ReadAll()$/;"	f	class:Design
ReadArray	RTree.h	/^  size_t ReadArray(TYPE* a_array, int a_count)$/;"	f	class:RTFileStream
ReadBlock	Design.cpp	/^Design::ReadBlock( ifstream& in )$/;"	f	class:Design
ReadLayerNum	Design.cpp	/^Design::ReadLayerNum( ifstream& in, string to_compare )$/;"	f	class:Design
ReadSearchUntil	Design.cpp	/^Design::ReadSearchUntil( ifstream& in, string str1, string str2 )$/;"	f	class:Design
ReadUnitsValue	Design.cpp	/^Design::ReadUnitsValue( ifstream& in, string to_compare )$/;"	f	class:Design
Rect	RTree.h	/^  struct Rect$/;"	s	class:RTree
RectSphericalVolume	RTree.h	/^ELEMTYPEREAL RTREE_QUAL::RectSphericalVolume(Rect* a_rect)$/;"	f	class:RTREE_QUAL
RectVolume	RTree.h	/^ELEMTYPEREAL RTREE_QUAL::RectVolume(Rect* a_rect)$/;"	f	class:RTREE_QUAL
Rectangle	main.h	/^typedef gtl::rectangle_data<int> Rectangle;$/;"	t
Remove	RTree.h	/^void RTREE_QUAL::Remove(const ELEMTYPE a_min[NUMDIMS], const ELEMTYPE a_max[NUMDIMS], const DATATYPE& a_dataId)$/;"	f	class:RTREE_QUAL
RemoveAll	RTree.h	/^void RTREE_QUAL::RemoveAll()$/;"	f	class:RTREE_QUAL
RemoveAllRec	RTree.h	/^void RTREE_QUAL::RemoveAllRec(Node* a_node)$/;"	f	class:RTREE_QUAL
RemoveRect	RTree.h	/^bool RTREE_QUAL::RemoveRect(Rect* a_rect, const DATATYPE& a_id, Node** a_root)$/;"	f	class:RTREE_QUAL
RemoveRectRec	RTree.h	/^bool RTREE_QUAL::RemoveRectRec(Rect* a_rect, const DATATYPE& a_id, Node* a_node, ListNode** a_listNode)$/;"	f	class:RTREE_QUAL
Reset	RTree.h	/^void RTREE_QUAL::Reset()$/;"	f	class:RTREE_QUAL
RtreeRect	WireRTree.h	/^  RtreeRect(int llx, int lly, int urx, int ury)$/;"	f	struct:RtreeRect
RtreeRect	WireRTree.h	/^struct RtreeRect$/;"	s
Save	RTree.h	/^bool RTREE_QUAL::Save(RTFileStream& a_stream)$/;"	f	class:RTREE_QUAL
Save	RTree.h	/^bool RTREE_QUAL::Save(const char* a_fileName)$/;"	f	class:RTREE_QUAL
SaveRec	RTree.h	/^bool RTREE_QUAL::SaveRec(Node* a_node, RTFileStream& a_stream)$/;"	f	class:RTREE_QUAL
Search	RTree.h	/^bool RTREE_QUAL::Search(Node* a_node, Rect* a_rect, int& a_foundCount, bool __cdecl a_resultCallback(DATATYPE a_data, void* a_context), void* a_context)$/;"	f	class:RTREE_QUAL
Search	RTree.h	/^int RTREE_QUAL::Search(const ELEMTYPE a_min[NUMDIMS], const ELEMTYPE a_max[NUMDIMS], bool __cdecl a_resultCallback(DATATYPE a_data, void* a_context), void* a_context)$/;"	f	class:RTREE_QUAL
SetBox	myShape.cpp	/^myShape::SetBox(int xl, int yl, int xh, int yh)$/;"	f	class:myShape
SetID	myShape.h	/^  void    SetID(int id) { m_id = id; }$/;"	f	class:myShape
SetPoints	myShape.cpp	/^myShape::SetPoints( oaPointArray & vpoints )$/;"	f	class:myShape
SetRealBoxes	myShape.cpp	/^myShape::SetRealBoxes(vector<oaBox> & vBoxes)$/;"	f	class:myShape
SplitNode	RTree.h	/^void RTREE_QUAL::SplitNode(Node* a_node, Branch* a_branch, Node** a_newNode)$/;"	f	class:RTREE_QUAL
StackElement	RTree.h	/^    struct StackElement$/;"	s	class:RTree::Iterator
TouchComponentCompute_RTree	Design.cpp	/^Design::TouchComponentCompute_RTree()$/;"	f	class:Design
WireRTree	WireRTree.h	/^  WireRTree() {}$/;"	f	class:WireRTree
WireRTree	WireRTree.h	/^class WireRTree$/;"	c
Write	RTree.h	/^  size_t Write(const TYPE& a_value)$/;"	f	class:RTFileStream
WriteArray	RTree.h	/^  size_t WriteArray(const TYPE* a_array, int a_count)$/;"	f	class:RTFileStream
_DESIGN_H_	Design.h	2;"	d
_MAIN_H_	main.h	2;"	d
_MYSHAPE_H_	myShape.h	2;"	d
_PTR_H_	PTR.h	10;"	d
_WIRE_RTREE_H_	WireRTree.h	2;"	d
__cdecl	RTree.h	22;"	d
bottom	myShape.h	/^  int     bottom()   { return m_realBox->bottom();}$/;"	f	class:myShape
bottom	myShape.h	/^  int bottom() {return y1();}$/;"	f	class:myBox
compress	PTR.cpp	/^PTR::compress(oaPointArray & points, int difference)$/;"	f	class:PTR
compress_old	PTR.cpp	/^PTR::compress_old(oaPointArray & points, int difference)$/;"	f	class:PTR
dx	myShape.h	/^myBox::dx() const$/;"	f	class:myBox
dy	myShape.h	/^myBox::dy() const$/;"	f	class:myBox
findLine	PTR.cpp	/^PTR::findLine(const oaPointArray points)$/;"	f	class:PTR
getArea	myShape.h	/^myBox::getArea()$/;"	f	class:myBox
getMinX	PTR.cpp	/^PTR::getMinX(const oaPointArray points)$/;"	f	class:PTR
getMinY	PTR.cpp	/^PTR::getMinY(const oaPointArray points)$/;"	f	class:PTR
insert	WireRTree.cpp	/^WireRTree::insert(myShape* myshape)$/;"	f	class:WireRTree
isHor	myShape.h	/^myBox::isHor() const$/;"	f	class:myBox
layerMax_	Design.h	/^  int         layerMax_;$/;"	m	class:Design
layerMerge_	Design.h	/^  int         layerMerge_;$/;"	m	class:Design
left	myShape.h	/^  int     left()     { return m_realBox->left(); }$/;"	f	class:myShape
left	myShape.h	/^  int left()   {return x1();}$/;"	f	class:myBox
library_	Design.h	/^  string      library_;$/;"	m	class:Design
ll	WireRTree.h	/^  int ll[2];    \/\/0:x, 1:y$/;"	m	struct:RtreeRect
m_DPLBoxes	myShape.h	/^  set<myBox* > m_DPLBoxes;   \/\/ conflict candidates$/;"	m	class:myBox
m_MergedWireIDs	Design.h	/^  vector< vector<int> >      m_MergedWireIDs;$/;"	m	class:Design
m_Metals	Design.h	/^  vector< vector<myShape*> > m_Metals;$/;"	m	class:Design
m_Polygons	Design.h	/^  vector<Polygon>            m_Polygons;$/;"	m	class:Design
m_TouchBoxes	myShape.h	/^  set<myBox* > m_TouchBoxes; \/\/ stitch candidates$/;"	m	class:myBox
m_area	RTree.h	/^    ELEMTYPEREAL m_area[2];$/;"	m	struct:RTree::PartitionVars
m_branch	RTree.h	/^    Branch m_branch[MAXNODES];                    \/\/\/< Branch$/;"	m	struct:RTree::Node
m_branchBuf	RTree.h	/^    Branch m_branchBuf[MAXNODES+1];$/;"	m	struct:RTree::PartitionVars
m_branchCount	RTree.h	/^    int m_branchCount;$/;"	m	struct:RTree::PartitionVars
m_branchIndex	RTree.h	/^      int m_branchIndex;$/;"	m	struct:RTree::Iterator::StackElement
m_child	RTree.h	/^      Node* m_child;                              \/\/\/< Child node$/;"	m	union:RTree::Branch::__anon3
m_count	RTree.h	/^    int m_count;                                  \/\/\/< Count$/;"	m	struct:RTree::Node
m_count	RTree.h	/^    int m_count[2];$/;"	m	struct:RTree::PartitionVars
m_cover	RTree.h	/^    Rect m_cover[2];$/;"	m	struct:RTree::PartitionVars
m_coverSplit	RTree.h	/^    Rect m_coverSplit;$/;"	m	struct:RTree::PartitionVars
m_coverSplitArea	RTree.h	/^    ELEMTYPEREAL m_coverSplitArea;$/;"	m	struct:RTree::PartitionVars
m_data	RTree.h	/^      DATATYPE m_data;                            \/\/\/< Data Id or Ptr$/;"	m	union:RTree::Branch::__anon3
m_file	RTree.h	/^  FILE* m_file;$/;"	m	class:RTFileStream
m_id	myShape.h	/^  int             m_id;	        \/\/ wire id for current layer$/;"	m	class:myShape
m_id	myShape.h	/^  int  m_id;			    \/\/ temperal id$/;"	m	class:myBox
m_interbox	myShape.h	/^  oaBox*       m_interbox;$/;"	m	class:myBox
m_level	RTree.h	/^    int m_level;                                  \/\/\/< Leaf is zero, others positive$/;"	m	struct:RTree::Node
m_max	RTree.h	/^    ELEMTYPE m_max[NUMDIMS];                      \/\/\/< Max dimensions of bounding box $/;"	m	struct:RTree::Rect
m_min	RTree.h	/^    ELEMTYPE m_min[NUMDIMS];                      \/\/\/< Min dimensions of bounding box $/;"	m	struct:RTree::Rect
m_minFill	RTree.h	/^    int m_minFill;$/;"	m	struct:RTree::PartitionVars
m_myShape	myShape.h	/^  myShape*     m_myShape;$/;"	m	class:myBox
m_next	RTree.h	/^    ListNode* m_next;                             \/\/\/< Next in list$/;"	m	struct:RTree::ListNode
m_node	RTree.h	/^      Node* m_node;$/;"	m	struct:RTree::Iterator::StackElement
m_node	RTree.h	/^    Node* m_node;                                 \/\/\/< Node$/;"	m	struct:RTree::ListNode
m_partition	RTree.h	/^    int m_partition[MAXNODES+1];$/;"	m	struct:RTree::PartitionVars
m_realBox	myShape.h	/^  oaBox*          m_realBox;    \/\/ for "polygon" store its bounding box$/;"	m	class:myShape
m_realBoxes	myShape.h	/^  vector<myBox* > m_realBoxes;  \/\/ rectangles after input$/;"	m	class:myShape
m_rect	RTree.h	/^    Rect m_rect;                                  \/\/\/< Bounds$/;"	m	struct:RTree::Branch
m_root	RTree.h	/^  Node* m_root;                                    \/\/\/< Root of tree$/;"	m	class:RTree
m_rtree	Design.h	/^  WireRTree                  m_rtree;$/;"	m	class:Design
m_stack	RTree.h	/^    StackElement m_stack[MAX_STACK];              \/\/\/< Stack as we are doing iteration instead of recursion$/;"	m	class:RTree::Iterator
m_taken	RTree.h	/^    int m_taken[MAXNODES+1];$/;"	m	struct:RTree::PartitionVars
m_tos	RTree.h	/^    int m_tos;                                    \/\/\/< Top Of Stack index$/;"	m	class:RTree::Iterator
m_total	RTree.h	/^    int m_total;$/;"	m	struct:RTree::PartitionVars
m_tree	WireRTree.h	/^  RTree<myShape*, int, 2, float> m_tree;$/;"	m	class:WireRTree
m_unitSphereVolume	RTree.h	/^  ELEMTYPEREAL m_unitSphereVolume;                 \/\/\/< Unit sphere constant for required number of dimensions$/;"	m	class:RTree
m_vpoints	myShape.h	/^  oaPointArray    m_vpoints;$/;"	m	class:myShape
main	main.cpp	/^main(int argc, char* argv[])$/;"	f
myBox	myShape.h	/^  myBox(oaBox* pBox) { m_id=-1; m_interbox = pBox; }$/;"	f	class:myBox
myBox	myShape.h	/^class myBox$/;"	c
myShape	myShape.cpp	/^myShape::myShape()$/;"	f	class:myShape
myShape	myShape.cpp	/^myShape::myShape(int xl, int yl, int xh, int yh)$/;"	f	class:myShape
myShape	myShape.h	/^class myShape$/;"	c
myfunction	myShape.cpp	/^bool myfunction(myBox* mybox1, myBox* mybox2)$/;"	f
operator *	RTree.h	/^    DATATYPE& operator*()$/;"	f	class:RTree::Iterator
operator *	RTree.h	/^    const DATATYPE& operator*() const$/;"	f	class:RTree::Iterator
operator ++	RTree.h	/^    bool operator++()                             { return FindNextData(); }$/;"	f	class:RTree::Iterator
parseParameters	Design.cpp	/^Design::parseParameters(int argc, char** argv)$/;"	f	class:Design
print	PTR.cpp	/^PTR::print(const oaPointArray points, int min_x, int min_y)$/;"	f	class:PTR
print	myShape.cpp	/^myShape::print()$/;"	f	class:myShape
printUsage	main.cpp	/^printUsage()$/;"	f
printWelcome	main.cpp	/^printWelcome()$/;"	f
ratio_	Design.h	/^  double      ratio_;$/;"	m	class:Design
right	myShape.h	/^  int     right()    { return m_realBox->right(); }$/;"	f	class:myShape
right	myShape.h	/^  int right()  {return x2();}$/;"	f	class:myBox
rtreeSearchCB	WireRTree.cpp	/^WireRTree::rtreeSearchCB(myShape* data, void* arg)$/;"	f	class:WireRTree
s_searchResult	WireRTree.cpp	/^vector<myShape*> WireRTree::s_searchResult;$/;"	m	class:WireRTree	file:
s_searchResult	WireRTree.h	/^  static vector<myShape*> s_searchResult;$/;"	m	class:WireRTree
searchoaBox	WireRTree.cpp	/^WireRTree::searchoaBox(oaBox* bbox)$/;"	f	class:WireRTree
size	WireRTree.h	/^  int size(){return m_tree.Count();}$/;"	f	class:WireRTree
top	myShape.h	/^  int     top()      { return m_realBox->top();}$/;"	f	class:myShape
top	myShape.h	/^  int top()    {return y2();}$/;"	f	class:myBox
ur	WireRTree.h	/^  int ur[2];$/;"	m	struct:RtreeRect
x1	myShape.h	/^myBox::x1() const$/;"	f	class:myBox
x2	myShape.h	/^myBox::x2() const$/;"	f	class:myBox
y1	myShape.h	/^myBox::y1() const$/;"	f	class:myBox
y2	myShape.h	/^myBox::y2() const$/;"	f	class:myBox
~Design	Design.cpp	/^Design::~Design()$/;"	f	class:Design
~Iterator	RTree.h	/^    ~Iterator()                                   { }$/;"	f	class:RTree::Iterator
~RTFileStream	RTree.h	/^  ~RTFileStream()$/;"	f	class:RTFileStream
~RTree	RTree.h	/^RTREE_QUAL::~RTree()$/;"	f	class:RTREE_QUAL
~myShape	myShape.cpp	/^myShape::~myShape()$/;"	f	class:myShape
